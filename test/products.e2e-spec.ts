import { getRepositoryToken } from '@nestjs/typeorm';
import { HttpStatus, INestApplication, Logger } from '@nestjs/common';
import { Test } from '@nestjs/testing';
import { ConfigModule } from '@nestjs/config';
import { Repository } from 'typeorm';
import { randNumber, randText, randUrl, randUuid } from '@ngneat/falso';
import * as request from 'supertest';

import { ProductsModule } from '@/products/products.module';
import { AuthModule } from '@/auth/auth.module';

import { User } from '@/models/user.entity';
import { Role } from '@/models/role.enum';
import { Product } from '@/models/product.entity';

import { dbModule } from './__utils__/db';
import { Auth, getAuth } from './__utils__/auth';
import { randProductToSave, randProductsToSave } from './__utils__/product';
import { bootstrap } from './__utils__/bootstrap';

describe('ProductModule (e2e)', () => {
  let app: INestApplication;
  let usersRepo: Repository<User>;

  let productsRepo: Repository<Product>;

  let admin: Auth;

  beforeAll(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [
        ConfigModule.forRoot(),
        AuthModule,
        ProductsModule,
        dbModule('products'),
      ],
    }).compile();

    app = moduleRef.createNestApplication();
    usersRepo = moduleRef.get(getRepositoryToken(User));
    productsRepo = moduleRef.get(getRepositoryToken(Product));

    await bootstrap(app);

    app.useLogger(new Logger());
  });

  beforeEach(async () => {
    await usersRepo.delete({});
    await productsRepo.delete({});

    admin = await getAuth(usersRepo, app, [Role.User, Role.Admin]);
  });

  afterAll(async () => {
    await app.close();
  });

  it('Should be defined', () => {
    expect(app).toBeDefined();
  });

  describe('GET /product', () => {
    it('Should return all products', async () => {
      const productsData = randProductsToSave(10);
      const products = await productsRepo.save(productsData);

      await request(app.getHttpServer())
        .get('/products')
        .expect(200)
        .expect((res) => expect(res.body).toEqual(products));
    });
  });

  describe('GET /products/id/:id', () => {
    it('Should return a product by id', async () => {
      const productData = randProductToSave();
      const product = await productsRepo.save(productData);

      await request(app.getHttpServer())
        .get(`/products/id/${product.id}`)
        .expect((res) => expect(res.body).toEqual(product));
    });
  });

  describe('GET /products/slug/:slug', () => {
    it('Should return a product by slug', async () => {
      const slug = randText();
      const product = {
        ...randProductToSave(),
        slug,
      };
      const productsData = [
        ...randProductsToSave(4),
        product,
        ...randProductsToSave(9),
      ];

      await productsRepo.save(productsData);

      await request(app.getHttpServer())
        .get(`/products/slug/${slug}`)
        .expect(200)
        .expect((res) =>
          expect(res.body).toEqual({ ...product, id: expect.any(String) }),
        );
    });
  });

  describe('POST /products Auth Admin', () => {
    it('Should create a product ', async () => {
      const product = randProductToSave();

      await request(app.getHttpServer())
        .post('/products')
        .auth(...admin.auth)
        .send(product)
        .expect(201)
        .expect((res) =>
          expect(res.body).toEqual({ ...product, id: expect.any(String) }),
        );
    });

    it('Should create a product with generated slug', async () => {
      const product = {
        title: 'some Title test',
        price: randNumber(),
        photo: randUrl(),
      };

      await request(app.getHttpServer())
        .post('/products')
        .auth(...admin.auth)
        .send(product)
        .expect(201)
        .expect((res) =>
          expect(res.body).toEqual({
            ...product,
            slug: 'some-Title-test',
            id: expect.any(String),
          }),
        );
    });
  });

  describe('PUT /products/:id Auth Admin', () => {
    it('Should update a product', async () => {
      const productToSave = randProductToSave();
      const product = await productsRepo.save(productToSave);
      const updatedFields = {
        price: randNumber(),
        photo: randUrl(),
      };

      await request(app.getHttpServer())
        .put(`/products/${product.id}`)
        .auth(...admin.auth)
        .send(updatedFields)
        .expect(200)
        .expect((res) =>
          expect(res.body).toEqual({
            ...product,
            ...updatedFields,
          }),
        );
    });

    it('Should update a product and regenerate slug', async () => {
      const productData = randProductToSave();
      const product = await productsRepo.save({
        ...productData,
        title: 'some Title test',
        // generated by title
        slug: 'some-Title-test',
      });

      await request(app.getHttpServer())
        .put(`/products/${product.id}`)
        .auth(...admin.auth)
        .send({
          title: 'new title updated',
        })
        .expect(200)
        .expect((res) =>
          expect(res.body).toEqual({
            ...product,
            title: 'new title updated',
            slug: 'new-title-updated',
          }),
        );
    });

    it('Should update a product without regenerating slug', async () => {
      const productData = randProductToSave();
      const product = await productsRepo.save({
        ...productData,
        title: 'some Title test',
        slug: 'not-generated-slug',
      });
      const title = randText();

      await request(app.getHttpServer())
        .put(`/products/${product.id}`)
        .auth(...admin.auth)
        .send({
          title,
        })
        .expect(200)
        .expect((res) =>
          expect(res.body).toEqual({
            ...product,
            title,
          }),
        );
    });

    it('Should not update a not existing product', async () => {
      await request(app.getHttpServer())
        .put(`/products/${randUuid()}`)
        .auth(...admin.auth)
        .send({
          title: randText(),
        })
        .expect(HttpStatus.BAD_REQUEST)
        .expect((res) =>
          expect(res.body.message).toEqual(
            'Product with that id has not been found',
          ),
        );
    });
  });

  describe('DELETE /products/:id Auth Admin', () => {
    it('Should delete a product by id ', async () => {
      const productData = randProductToSave();
      const product = await productsRepo.save(productData);

      await request(app.getHttpServer())
        .delete(`/products/${product.id}`)
        .auth(...admin.auth)
        .expect(200)
        .expect((res) => expect(res.body).toEqual({ deleted: true }));
    });

    it('Should not delete a product by id because of db error', async () => {
      const productData = randProductToSave();
      const product = await productsRepo.save(productData);
      jest.spyOn(productsRepo, 'delete').mockRejectedValue(new Error());

      await request(app.getHttpServer())
        .delete(`/products/${product.id}`)
        .auth(...admin.auth)
        .expect(200)
        .expect((res) => expect(res.body).toEqual({ deleted: false }));
    });
  });
});
